<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>{{ project.title }} — Ingestion</title>

  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

  <!-- Styles -->
  <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>

<body>

  <!-- Header -->
  <header class="container header">
    <a class="brand" href="{{ url_for('index') }}">Living Repository</a>
    <nav class="nav">
      <a href="{{ url_for('projects') }}">Projects</a>
      <a href="{{ url_for('logout') }}">Logout</a>
    </nav>
  </header>

  <main class="container">

    <!-- Step Header -->
    <div class="ingest-steps">
      <div class="ingest-step active" data-step="dashboard" aria-current="page">Dashboard</div>
      <div class="ingest-step" data-step="upload">Upload</div>
      <div class="ingest-step" data-step="tags">AI Tag Suggestions</div>
      <div class="ingest-step" data-step="metadata">Metadata</div>
    </div>

    <div class="ingest-screens">

      <!-- DASHBOARD -->
      <section class="screen active" data-screen="dashboard">
        <h2 class="h2">{{ project.title }} — Documents</h2>
        <div style="margin:8px 0 24px 0;">
          <a href="{{ url_for('project_detail', project_id=project_id) }}">
            <button class="btn btn-outline">← Back to Project</button>
          </a>
        </div>

        <!-- Search with Filters -->
        <div class="search-container">
          <!-- Main Search -->
        <div class="main-search-row">
          <input id="docSearch" class="input" placeholder="Search documents…" style="flex:1;" />
          <button id="docSearchBtn" class="btn btn-primary">Search</button>
        </div>

        <!--Filters Grid -->
        <div class="search-filters">
        <!-- Tag Filter -->
         <div class="filter-group">
          <label class="filter-label">Tags</label>
          <input id="filterTags" class="filter-input" placeholder="Filter by tags..." />
         </div>

        <!-- Author Filter -->
         <div class="filter-group">
          <label class="filter-label">Author</label>
          <input id="filterAuthor" class="filter-input" placeholder="Filter by author..." />
         </div>

        <!-- Status Filter -->
         <div class="filter-group">
          <label class="filter-label">Status</label>
          <select id="filterStatus" class="filter-input">
            <option value="">All Status</option>
            <option value="Complete">Complete</option>
            <option value="Pending">Pending</option>
          </select>
         </div>

        <!-- Clear all button -->
         <div class="filter-actions">
          <button id="clearFilters" class="clear-filters-btn btn">Clear All</button>
         </div>
        </div>

        <!-- Active Filters Display -->
         <div id="activeFilters" class="active-filters" style="display: none;"></div>
        </div>

        <!-- Search Results Info -->
         <div id="searchResultsInfo" class="search-results-info" style="display: none;"></div>

        <!-- Upload button -->
        <div style="display:flex; justify-content:center; margin-bottom:24px;">
          <button class="btn btn-primary btn-lg" id="btnGoUpload">+ Upload New Document</button>
        </div>

        <!-- Document List -->
        <div id="docList">
          {% for doc in documents %}
          <article class="doc-card" data-doc-id="{{ doc.doc_id }}"
            data-title="{{doc.title|lower }}"
            data-author="{{ (doc.author or 'Unknown')|lower }}"
            data-tags="{{ (doc.tags or '')|lower }}"
            data-status="{{ (doc.status or 'Pending')|lower }}">
            <a href="{{ url_for('document_detail', project_id=project_id, doc_id=doc.doc_id) }}"
              style="display:block; text-decoration:none; color:inherit;">
              <div class="doc-row">
                <div class="doc-title">{{ doc.title }}</div>
                <span class="badge
                  {% if doc.status == 'Complete' %}badge-success
                  {% elif doc.status in ['In Progress','in_progress','in progress'] %}badge-warning
                  {% elif doc.status in ['Failed','Error'] %}badge-danger
                  {% else %}badge-secondary{% endif %} status-badge">
                  {{ doc.status or "Pending" }}
                </span>
              </div>

              <div class="doc-meta">
                <span>Author: {{ doc.author or "Unknown" }}</span>
                <span>Updated: {{ doc.upload_date }}</span>
              </div>
            </a>

            {% if doc.tags %}
            <div class="doc-tags" style="margin-top:8px; display:flex; flex-wrap:wrap; gap:6px; align-items: center;">
              {% for tag in doc.tags.split(",") %}
              <span class="badge badge-secondary" style="text-transform: capitalize">{{ tag.strip() }}</span>
              {% endfor %}
              <button class="btn edit-btn btn-outline" data-doc-id="{{ doc.doc_id }}"
                style="margin-left: auto;">Edit</button>
            </div>
            {% endif %}


            {% if doc.status != 'Complete' %}
            <button class="btn btn-sm btn-primary process-btn" data-doc-id="{{ doc.doc_id }}">
              Process
            </button>
            {% endif %}
          </article>
          {% endfor %}
        </div>

      </section>

      <!-- UPLOAD -->
      <section class="screen" data-screen="upload">
        <h2 class="h2">Upload Document</h2>
        <form id="uploadForm" enctype="multipart/form-data">
          <div id="dropzone" class="dropzone" tabindex="0">
            <input id="fileInput" name="file" type="file"
              accept=".pdf,.doc,.docx,.xls,.xlsx,.jpg,.jpeg,.png,.tiff" hidden />
            <div class="dropzone-inner">
              <div class="drop-illustration">⬆</div>
              <div class="drop-title">Drag & drop file here</div>
              <div class="drop-sub">
                or <button id="browseBtn" type="button" class="btn btn-link">browse</button>
              </div>
              <div class="drop-hint">PDF, DOCX, XLS/XLSX, or image. Max 25MB.</div>
              <div id="filePicked" class="drop-picked" hidden></div>
            </div>
          </div>

          <input id="docTitle" name="title" class="input" placeholder="Document title" required />
          <textarea id="docDescription" name="description" class="input" placeholder="Optional description"></textarea>
          <select id="docPrivacy" name="privacy" class="select" required>
            <option value="public" selected>Public</option>
          <option value="private">Private</option>
          <option value="restricted">Restricted</option>
        </select>


          <div class="ingest-actions">
            <button class="btn btn-outline" id="backToDashboard" type="button">Back</button>
            <button type="submit" class="btn btn-primary">Upload</button>
          </div>
        </form>
      </section>

      <!-- TAGS -->
      <section class="screen" data-screen="tags">
        <h2 class="h2">AI Tag Suggestions</h2>
        <div class="chip-board" id="suggestedTags"></div>
        <div style="display:flex; gap:8px; margin-top:12px;">
          <input id="manualTag" class="input" placeholder="Add manual tag" />
          <button id="addTagBtn" class="btn btn-outline">Add Tag</button>
        </div>
        <div class="ingest-actions">
          <button class="btn btn-outline" id="backToUpload">Back</button>
          <button class="btn btn-primary" id="toMetadata">Continue</button>
        </div>
      </section>

      <!-- METADATA -->
      <section class="screen" data-screen="metadata">
        <h2 class="h2">Finalize Metadata</h2>
        <div class="card"
          style="padding: var(--space-6); border-radius:16px; background:#fff; box-shadow:var(--shadow);">
          <div class="group-block">
            <div class="group-title">Tags</div>
            <div class="chip-board" id="finalTags"></div>
          </div>
          <div class="group-block">
            <div class="group-title">Classification</div>
            <select id="classification" class="select">
            <option value="public">Public</option>
            <option value="internal" selected>Internal</option>
            <option value="private">Confidential</option>
        </select>
          </div>
          <div class="group-block">
            <div class="group-title">Reviewer</div>
            <input id="reviewer" class="input" list="reviewerList" placeholder="Start typing…" />
            <datalist id="reviewerList">
              <option value="Alex Johnson"></option>
              <option value="Priya Singh"></option>
              <option value="Taylor Wong"></option>
              <option value="Morgan Lee"></option>
            </datalist>
          </div>
          <div class="ingest-actions">
            <button class="btn btn-outline" id="backToTags">Back</button>
            <button class="btn btn-primary" id="submitRepo">Submit to Repository</button>
          </div>
        </div>
      </section>

    </div>
  </main>

  <footer class="container footer">
    <small>© <span id="year"></span> Living Repository</small>
  </footer>

  <!-- JS -->
  <script>
    const PROJECT_ID = "{{ project_id }}"; // must be top
    const screens = document.querySelectorAll('.screen');
    const steps = document.querySelectorAll('.ingest-step');
    const docList = document.getElementById('docList');
    const fileInput = document.getElementById('fileInput');
    const browseBtn = document.getElementById('browseBtn');
    const filePicked = document.getElementById('filePicked');
    const uploadForm = document.getElementById('uploadForm');
    const dropzone = document.getElementById('dropzone');

    // Search and filter elemetns
    const docSearch = document.getElementById('docSearch');
    const filterTags = document.getElementById('filterTags');
    const filterAuthor = document.getElementById('filterAuthor');
    const filterStatus = document.getElementById('filterStatus');
    const clearFiltersBtn = document.getElementById('clearFilters');
    const activeFiltersContainer = document.getElementById('activeFilters');
    const searchResultsInfo = document.getElementById('searchResultsInfo');
    const noResults = document.getElementById('noResults');

    let activeTagFilters = new Set();
    let activeAuthorFilters = new Set();
    let allDocCards =[];

    document.getElementById('year').textContent = new Date().getFullYear();

    //Initalise document cards array
    function initialiseDocCards() {
      allDocCards = Array.from(document.querySelectorAll('.doc-card'));
    }

    function goToScreen(screenName) {
      screens.forEach(s => s.classList.toggle('active', s.dataset.screen === screenName));
      steps.forEach(step => {
        const active = step.dataset.step === screenName;
        step.classList.toggle('active', active);
        if (active) step.setAttribute('aria-current', 'page');
        else step.removeAttribute('aria-current');
      });
    }

    // Navigation
    document.getElementById('btnGoUpload').addEventListener('click', () => goToScreen('upload'));
    document.getElementById('backToDashboard').addEventListener('click', () => goToScreen('dashboard'));
    document.getElementById('backToUpload')?.addEventListener('click', () => goToScreen('upload'));
    document.getElementById('backToTags')?.addEventListener('click', () => goToScreen('tags'));
    document.getElementById('toMetadata')?.addEventListener('click', () => goToScreen('metadata'));

        // Enhanced Search and Filter Functions
    function  performSearch() {
      const searchTerm = docSearch.value.toLowerCase().trim();
      const statusFilter = filterStatus.value.toLowerCase().trim();

      let visibleCount = 0;
      let totalCount = allDocCards.length;

      allDocCards.forEach(card => {
        const title = card.dataset.title || '';
        const author = card.dataset.author || '';
        const tags = card.dataset.tags || '';
        const status = card.dataset.status || '';

        // Main search only searches title
        const matchesSearch = !searchTerm || title.includes(searchTerm);

        // Check if all active tag filters are present
        let matchesTags = true;
        if (activeTagFilters.size > 0) {
          matchesTags = Array.from(activeTagFilters).some(tagFilter => tags.includes(tagFilter));
        }
        // Check if all active author filters are present
        let matchesAuthor = true;
        if (activeAuthorFilters.size > 0) {
          matchesAuthor = Array.from(activeAuthorFilters).some(authorFilter => author.includes(authorFilter));
        }
        const matchesStatus = !statusFilter || status.includes(statusFilter);

        const shouldShow = matchesSearch && matchesTags && matchesAuthor && matchesStatus;

        card.style.display = shouldShow ? 'block' : 'none';
        if (shouldShow) visibleCount++;
      });

      updateSearchResults(visibleCount, totalCount);
      updateActiveFilters();
    }

    // Update search results
    function updateSearchResults(visible, total) {
      if (hasActiveFilters()) {
        searchResultsInfo.style.display = 'block';
        searchResultsInfo.textContent = `Showing ${visible} of ${total} documents`;
        if (noResults) {
          noResults.style.display = visible === 0 ? 'block' : 'none';
        }
      } else {
        searchResultsInfo.style.display = 'none';
        if (noResults) {
          noResults.style.display = 'none';
        }
      }
    }

    // Active Filter functions
    function hasActiveFilters() {
      return docSearch.value.trim() !== '' ||
        activeTagFilters.size > 0 ||
        activeAuthorFilters.size > 0 ||
        filterStatus.value !== '';
    }

    function updateActiveFilters() {
      const activeFilters = [];

      if (docSearch.value.trim()) {
          activeFilters.push({ type: 'search', value: docSearch.value.trim(), label: `Search: "${docSearch.value.trim()}"` });
      }
      // Add each tag filter
      activeTagFilters.forEach(tag => {
        activeFilters.push({ type: 'tag', value: tag, label: `Tag: "${tag}"` });
      });
      // Add each author filter
      activeAuthorFilters.forEach(author => {
        activeFilters.push({ type: 'author', value: author, label: `Author: "${author}"` });
      });
      if (filterStatus.value) {
        activeFilters.push({ type: 'status', value: filterStatus.value, label: `Status: ${filterStatus.value}` });
      }

      if (activeFilters.length === 0) {
        activeFiltersContainer.style.display = 'none';
        return;
      }

      activeFiltersContainer.style.display = 'flex';
      activeFiltersContainer.innerHTML = activeFilters.map(filter =>
        `<span class="chip">
          ${filter.label}
          <span class="chip-x" data-filter-type="${filter.type}" data-filter-value="${filter.value}">X</span>
        </span>`
      ).join(' ');

      // Add event listeners to remove filter buttons
      activeFiltersContainer.querySelectorAll('.chip-x').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const filterType = e.target.dataset.filterType;
          const filterValue = e.target.dataset.filterValue;
          clearSpecificFilter(filterType, filterValue);
        });
      });
    }

    function clearSpecificFilter(filterType, filterValue) {
      switch(filterType) {
        case 'search':
          docSearch.value = '';
          break;
        case 'tag':
          activeTagFilters.delete(filterValue);
          break;
        case 'author':
          activeAuthorFilters.delete(filterValue);
          break;
        case 'status':
          filterStatus.value = '';
          break;
      }
      performSearch();
    }

    function clearAllFilters() {
      docSearch.value = '';
      activeTagFilters.clear();
      activeAuthorFilters.clear();
      filterTags.value = '';
      filterAuthor.value = '';
      filterStatus.value = '';
      performSearch();
    }

    // Event Listeners for Search and Filters
    function debounce(func, wait) {
      let timeout;
      return function executedFuntion(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    const debouncedSearch = debounce(performSearch, 300);

    // Add event listeners for search
    docSearch.addEventListener('input', debouncedSearch);
    // Handle tag filter with Enter key
    filterTags.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const tagValue = filterTags.value.trim();
        if  (tagValue) {
          activeTagFilters.add(tagValue.toLowerCase());
          filterTags.value = ''; // Clear input
          performSearch();
        }
      }
    });
    // Handle author filter with Enter key
    filterAuthor.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const authorValue = filterAuthor.value.trim();
        if (authorValue) {
          activeAuthorFilters.add(authorValue.toLowerCase());
          filterAuthor.value = '';
          performSearch();
        }
      }
    });
    filterStatus.addEventListener('change', performSearch);
    clearFiltersBtn.addEventListener('click', clearAllFilters);

    // File input
    browseBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', () => {
      if (fileInput.files.length > 0) {
        filePicked.hidden = false;
        filePicked.textContent = `Selected file: ${fileInput.files[0].name}`;
      } else { filePicked.hidden = true; }
    });

    // Process buttons
    function attachProcessButtons() {
      document.querySelectorAll('.process-btn').forEach(btn => {
        if (btn.dataset.bound) return;
        btn.dataset.bound = true;
        btn.addEventListener('click', e => {
          e.stopPropagation(); // don't trigger card link
          const docId = btn.dataset.docId;
          fetch(`/project/${PROJECT_ID}/document/${docId}/process`, { method: 'POST' })
            .then(res => res.json())
            .then(data => {
              if (data.success) {
                const card = btn.closest('.doc-card');
                const badge = card.querySelector('.status-badge');
                badge.textContent = 'Complete';
                badge.className = 'badge badge-success status-badge';
                btn.remove();
              } else alert('Failed to process document.');
            })
            .catch(console.error);
        });
      });
    }
    attachProcessButtons();

    // AJAX Upload
    uploadForm.addEventListener('submit', e => {
      e.preventDefault();
      const formData = new FormData(uploadForm);

      fetch(`/project/${PROJECT_ID}/upload`, { method: 'POST', body: formData })
        .then(res => res.json())
        .then (data => {
          if (data.success) {
            const article = document.createElement('article');
            article.className = 'doc-card';
            article.innerHTML = `
              <a href="/project/${PROJECT_ID}/document/${data.doc_id}" style="display:block; text-decoration:none; color:inherit;">
                <div class="doc-row">
                  <div class="doc-title">${data.title}</div>
                  <span class="badge badge-secondary">Pending</span>
                </div>
                ${data.description ? `<p class="text-sm muted" style="margin-top:6px;">${data.description}</p>` : ''}
              </a>
              <button class="btn btn-sm btn-primary process-btn" data-doc-id="${data.doc_id}">Process</button>
            `;
            docList.prepend(article);
            uploadForm.reset();
            filePicked.hidden = true;
            attachProcessButtons(); // bind the new button
            alert('Document uploaded successfully!');
            goToScreen('dashboard');
          } else alert('Upload failed');
        }).catch(console.error);
    });

    //Edit function
    document.addEventListener('click', function (e) {
      // Handle Edit button clicks
      if (e.target && e.target.classList.contains('edit-btn')) {
        e.preventDefault();
        const docId = e.target.getAttribute('data-doc-id');
        const docCard = e.target.closest('.doc-card');

        console.log('Edit button clicked for document:', docId);

        // Toggle edit mode
        toggleEditMode(docCard, e.target);
      }

      // Handle tag delete button clicks
      if (e.target && e.target.classList.contains('tag-delete-btn')) {
        e.preventDefault();
        const docId = e.target.getAttribute('data-doc-id');
        const tagText = e.target.getAttribute('data-tag');

        console.log('Deleting tag:', tagText, 'from document:', docId);

        // Remove the tag from the DOM
        deleteTagFromDatabase(docId, tagText, e.target);
      }

      // Handle add tag button clicks
      if (e.target && e.target.classList.contains('add-tag-btn')) {
        e.preventDefault();
        const docId = e.target.getAttribute('data-doc-id');
        const docCard = e.target.closest('.doc-card');

        console.log('Add tag button clicked for document:', docId);

        showAddTagInput(docCard, docId);
      }
    });

    function toggleEditMode(docCard, editBtn) {
      const isEditMode = docCard.classList.contains('edit-mode');

      if (isEditMode) {
        // Exit edit mode
        exitEditMode(docCard, editBtn);
      } else {
        // Enter edit mode
        enterEditMode(docCard, editBtn);
      }
    }

    function enterEditMode(docCard, editBtn) {
      // Add edit-mode class to the card
      docCard.classList.add('edit-mode');

      // Change button text to "Save"
      editBtn.textContent = 'Save';
      editBtn.classList.add('btn-success');

      const docId = docCard.getAttribute('data-doc-id');
      const docTagsContainer = docCard.querySelector('.doc-tags');

      // Find all tag badges in this card
      const tagBadges = docCard.querySelectorAll('.doc-tags .badge:not(.status-badge)');

      tagBadges.forEach(badge => {
        // Skip if delete button already exists
        if (badge.querySelector('.tag-delete-btn')) return;

        const tagText = badge.textContent.trim();

        // Create delete button
        const deleteBtn = document.createElement('span');
        deleteBtn.className = 'tag-delete-btn';
        deleteBtn.innerHTML = 'X';
        deleteBtn.setAttribute('data-doc-id', docId);
        deleteBtn.setAttribute('data-tag', tagText);
        deleteBtn.title = 'Delete tag';

        // Add hover effect
        badge.addEventListener('mouseenter', () => {
          if (!deleteBtn.matches(':hover')) {
            deleteBtn.style.color = 'white';
          }
        });

        badge.addEventListener('mouseleave', () => {
          if (!deleteBtn.matches(':hover')) {
            deleteBtn.style.color = '#000000';
          }
        });

        // Delete button specific hover - X becomes RED only
        deleteBtn.addEventListener('mouseenter', () => {
          deleteBtn.style.color = '#ef4444'; // Red color only
        });

        deleteBtn.addEventListener('mouseleave', () => {
          // Check if the badge is still being hovered
          const badgeHovered = badge.matches(':hover');

          if (badgeHovered) {
            deleteBtn.style.setProperty('color', 'white');
          } else {
            deleteBtn.style.setProperty('color', '#000000');
          }
        });

        // Append delete button to the badge
        badge.appendChild(deleteBtn);
      });

      // Add "+" button for adding new tags
      if (!docCard.querySelector('.add-tag-btn')) {
        const addTagBtn = document.createElement('button');
        addTagBtn.className = 'btn add-tag-btn';
        addTagBtn.innerHTML = '+';
        addTagBtn.setAttribute('data-doc-id', docId);
        addTagBtn.title = 'Add new tag';

        editBtn.parentNode.insertBefore(addTagBtn, editBtn);
      }

    }

    function exitEditMode(docCard, editBtn) {
      // Remove edit-mode class
      docCard.classList.remove('edit-mode');

      // Change button back to "Edit"
      editBtn.textContent = 'Edit';
      editBtn.classList.remove('btn-success');

      // Remove all delete buttons
      const deleteButtons = docCard.querySelectorAll('.tag-delete-btn');
      deleteButtons.forEach(btn => btn.remove());

      // Remove add tag button
      const addTagBtn = docCard.querySelector('.add-tag-btn');
      if(addTagBtn) {
        addTagBtn.remove();
      }

      // Remove add tage input container if it exists
      const addTagInput = docCard.querySelector('.add-tag-input-container');
      if (addTagInput) {
        addTagInput.remove();
      }
    }

    function showAddTagInput(docCard, docId) {
      if (docCard.querySelector('.add-tag-input-container')) {
        return;
      }

      const docTagsContainer = docCard.querySelector('.doc-tags');
      const addTagBtn = docCard.querySelector('.add-tag-btn');

      // Create input container
      const inputContainer = document.createElement('div');
      inputContainer.className = 'add-tag-input-container';

      // Create input field
      const tagInput = document.createElement('input');
      tagInput.type = 'text';
      tagInput.placeholder = 'Enter new tag...';

      // Create confirm button
      const confirmBtn = document.createElement('button');
      confirmBtn.className = 'confirm-btn';
      confirmBtn.textContent = '✓';
      confirmBtn.title = 'Add tag';

      // Append elements to container
      inputContainer.appendChild(tagInput);
      inputContainer.appendChild(confirmBtn);

      // Insert container after the doc-tags div
      docTagsContainer.parentNode.insertBefore(inputContainer, docTagsContainer.nextSibling);

      // Focus the input
      tagInput.focus();

      //Handle confirm button click
      confirmBtn.addEventListener('click', () => {
        const tagText = tagInput.value.trim();
        if (tagText) {
          addTagToDatabase(docId, tagText, docCard, inputContainer);
        }
      });

      //Handle Enter key input
      tagInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          const tagText = tagInput.value.trim();
          if (tagText) {
            addTagToDatabase(docId, tagText, docCard, inputContainer);
          }
        }
      });
    }

    // Function to add tag to database
    async function addTagToDatabase(docId, tagText, docCard, inputContainer) {
      try {
        const response = await fetch(`/project/${PROJECT_ID}/document/${docId}/tags`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            tag: tagText
          })
        });

        const result = await response.json();

        if (result.success) {
          // Create new tag badge
          const newTagBadge = document.createElement('span');
          newTagBadge.className = 'badge badge-secondary';
          newTagBadge.textContent = tagText;

          // Add delete button to new tag, per edit mode
          const deleteBtn = document.createElement('span');
          deleteBtn.className = 'tag-delete-btn';
          deleteBtn.innerHTML = 'X';
          deleteBtn.setAttribute('data-doc-id', docId);
          deleteBtn.setAttribute('data-tag', tagText);
          deleteBtn.title = 'Delete tag';

          // Add hover effects
          newTagBadge.addEventListener('mouseenter', () => {
            if (!deleteBtn.matches(':hover')) {
              deleteBtn.style.color = 'white';
            }
          });

          newTagBadge.addEventListener('mouseleave', () => {
            if (!deleteBtn.matches(':hover')) {
              deleteBtn.style.color = '#000000';
            }
          });

          deleteBtn.addEventListener('mouseenter', () => {
            deleteBtn.style.color = '#ef4444';
          });

          deleteBtn.addEventListener('mouseleave', () => {
            const badgeHovered = newTagBadge.matches(':hover');
            if (badgeHovered) {
              deleteBtn.style.setProperty('color', 'white');
            } else {
              deleteBtn.style.setProperty('color', '#000000');
            }
          });

          newTagBadge.appendChild(deleteBtn);

          //Insert new tag in the tags container
          const docTagsContainer = docCard.querySelector('.doc-tags');
          docTagsContainer.insertBefore(newTagBadge, docTagsContainer.firstChild);

          // Remove the input container
          inputContainer.remove();

          console.log(`Successfully added tag: ${tagText}`);
        } else {
          console.error('Failed to add tag:', result.error);
          alert(`Error: ${result.error}`);
        }

      } catch (error) {
        console.error('Network error adding tag:', error);
        alert('Network error - tag not added');
      }
    }

    // Function to delete tag from database
    async function deleteTagFromDatabase(docId, tagText, deleteButton) {
      try {
        const response = await fetch(`/project/${PROJECT_ID}/document/${docId}/tags`, {
          method: 'DELETE',
          headers: {
            'Content-Type': 'application/json',
          },

          body: JSON.stringify({
            tag: tagText
          })
        });

        const result = await response.json();

        if (result.success) {
          const tagBadge = deleteButton.closest('.badge');
          if (tagBadge) {
            tagBadge.remove();
          }
          console.log(`Successfully deleted tag: ${tagText}`);
        } else {
          console.error('Failed to delete tag:', result.error);
          alert(`Error: ${result.error}`);
        }

      } catch (error) {
        console.error('Network error deleting tag:', error);
        alert('Network error - tag not deleted');
      }
    }

    function validateFile(file) {
      if (!file) return { ok: false, reason: 'No file selected' };
      const extOk = /\.(pdf|doc|docx|xls|xlsx|jpg|jpeg|png|tiff)$/i.test(file.name);
      const sizeOk = file.size <= 25 * 1024 * 1024; // 25MB
      if (!extOk) return { ok: false, reason: 'PDF, DOC/DOCX, XLS/XLSX, or image only' };
      if (!sizeOk) return { ok: false, reason: 'File too large (max 25MB)' };
      return { ok: true };
    }

    function setPicked(file) {
      if (!filePicked) return;
      filePicked.hidden = false;
      filePicked.textContent = `Selected file: ${file.name}`;
    }

    // Global drag & drop guard
    // Prevent the browser from opening the file when it's dropped on the page.
    ['dragenter','dragover'].forEach(evt => {
      dropzone?.addEventListener(evt, (e) => {
        e.preventDefault();
        e.stopPropagation();
        dropzone.classList.add('dragover');
      });
    });

    ['dragleave','drop'].forEach(evt => {
      dropzone?.addEventListener(evt, (e) => {
        e.preventDefault();
        e.stopPropagation();
        dropzone.classList.remove('dragover');
      });
    });

    dropzone?.addEventListener('drop', (e) => {
      e.preventDefault();
      e.stopPropagation();
      dropzone.classList.remove('dragover');

      const f = e.dataTransfer?.files?.[0];
      if (!f) return;
      const res = validateFile(f);
      if (!res.ok) { alert(res.reason); return; }
      const dt = new DataTransfer();
      dt.items.add(f);
      fileInput.files = dt.files;
      setPicked(f);
    });

    //Initialise document cards on page load
    initialiseDocCards();
  </script>
</body>

</html>